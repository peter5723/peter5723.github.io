# xv6 源码阅读

xv6 有两个 cpu（hart）

## 1. 启动第一个进程

首先我们来看一下如何启动 xv6 以及开始第一个进程吧。（课程教材的 2.6 节）

机器启动后，xv6 从 `kernel/entry.S` 开始运行。启动时硬件分页机制未打开，物理地址等于虚拟地址。qemu 将 xv6 加载到地址 `0x80000000`,然后`_entry` 中设置栈， 栈的地址在 `start.c` 中确定，大小为 4096 乘以 CPU 个数，将 sp 的位置设置为栈顶（stack0+4096\*id）。设置好栈后，跳转到 `start()` 函数。


`start()` 函数的工作首先是在 machine 模式下进行一些必要的配置，然后切换到 supervisor 模式。这些配置包括，将 `main` 函数的地址写到 mepc 寄存器中，将 0 写入 satp 寄存器中使得在 supervisor 模式下，关闭页表地址的转换。然后打开时钟中断。执行完这些之后，使用 `mret` 进入 s 模式，并跳转到 `main()` 函数。

在 `main()` 函数中进行一系列必要的初始化后，调用 `user_init()`（在`proc.c`）来创建第一个进程（initcode.S）。这个进程执行 `exec` 系统调用，打开 `init` 程序，`init` 程序(init.c)打开shell，就这样完成了第一个进程，启动了系统。


## 2. 创建新进程

在 `proc.c` 中。主要是 `allocproc()` 函数，首先给新进程创建一个新的 `pid`，使用 `allocpid()` 函数；再给进程分配 `trapframe` （PCB），这里面储存进程中断需要的变量；最后为用户进程分配页表，用于虚拟地址转化为物理地址。`vm.c` 中的 `mappages` 函数创建新的 PTE（页表项），而硬件 mmu 根据这些页表物理内存地址转化为虚拟内存地址（qemu）的工作。

系统分配空间用的都是 `kalloc.c`  中定义的 `kalloc` 函数，一次分配 4096 Byte 的内存，是一个页表的大小。`kalloc` 函数返回的是物理地址。


