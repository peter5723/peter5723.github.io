# RISC-V

这篇用来介绍 risc-v 的学习记录。

## 0. 介绍

什么是 risc-v？我觉得很可悲的一点是，我去年学了小白老师上的汇编语言，在本专业又学了嵌入式系统这门课，在这个月之前，我连什么是 ISA 都没有搞清楚。所以，一门介绍计算机系统的课是很值得上的吧。

我们写出来的高级语言，被编译器翻译成汇编语言，汇编语言则和机器代码一一对应，机器代码可以直接执行。
程序就是这么跑起来的。
而实际上，对于不同的机器（处理器），它能支持的汇编语言也是不一样的。
我们把一套汇编构成的指令集体系结构称为 ISA (Instruction-set Architecture)。
一种处理器只能支持它支持的 ISA，
毕竟做同样的事情的汇编指令，不同的 ISA 对应的机器码是不同的。
现在市面上已经有了很多不同的处理器，它们所使用的 ISA 都是不一样的。
比如，我们的计算机通常使用 Intel 处理器，它使用的 ISA 就是 x86 了。
我们的手机等很多终端设备使用 Arm 处理器，用的 ISA 就是 Arm 和 Thumb。
除此之外，非常常用的 ISA 还有 misp 和 risc-v。
这篇博客主要就是介绍 risc-v 的。

???+ note "Some notes of x86"
    开始 riscv 之前，简单讲几句 x86。

    在小白的课上学习的 8086 汇编，正是 x86 的一种，只不过是 16 位的汇编，非常古老了。值不值得用它来学习 x86，见仁见智。但不管 16 位，32 位还是 64 位，本质上是一样的，在 windows 下反汇编 （可以用 IDA、vs 等），汇编都是 x86 的。所以学习了 16 位以后向外扩展还是很容易的。

    然后我记得在 csapp 中，要在 Linux 系统下，调试著名的 bomb lab，用 objdump 进行反汇编，得到的汇编我还以为又是一种新的汇编语言。但是实际上得到的汇编仍然是属于 x86 ISA 的。

    两者实际上只是语法风格的不同。windows 下更常用的 x86 风格称作 Intel 风格；而 Linux 下更常用的风格称作 AT&T 风格。
    
    举个例子同样的语句，将寄存器 rdx 中的值复制到寄存器 rbx 中，在 Intel 风格下写作：
    ```
    mov rbx, rdx
    ```
    目标操作数在前，源操作数在后。

    而在 AT&T 风格下写作：
    ```
    movq %rdx, %rbx
    ```
    源操作数（source）在前，目标操作数（destination）在后。

    x86 是典型的 CISC ISA，就是说它的指令数量非常多，很繁杂。与此相对应的就是 RISC，精简化指令集，指令数量更少。
    ARM 和 risc-v 都属于 RISC 指令集。

下面就介绍 riscv 了。开始之前，先放一些可能需要的链接吧：

优秀笔记：<https://note.tonycrane.cc/cs/pl/riscv/>

官网：<https://riscv.org/>