# 链接与程序结构


这一章会简单介绍链接和程序的结构。事实上到做毕设我才体会到链接的力量：将一个大工程分解为各个可以独立修改、编译的模块。

## 1. ELF 文件结构

可以 `man 5 elf` 来获得关于 ELF 文件的信息。

别人也有一些介绍，比如：

<https://zhuanlan.zhihu.com/p/286088470>

<https://blog.csdn.net/npy_lp/article/details/102604380>

ELF 是 linux 系统下的可执行目标文件格式。理解它就理解了程序的结构。

先来一张图来介绍 ELF 的文件结构。我们可以从 section（节）和 segment（段）两种视角来看 ELF 文件是怎么组织的。

![](https://cdn.jsdelivr.net/gh/peter5723/imagehost/links1.jpg)

### Section 视角

Section 视角提供了用于链接与重定位的信息。从节的角度，ELF header（ELF 头）介绍了这个 ELF 文件的基本信息，比如大小、机器类型、程序入口地址、Section header table （节头部表）的文件偏移等等。ELF 头之后是 Segment header table（程序头表），包括了段的信息，段在后面会介绍。文件的末尾是节头部表，描述了不同节的位置和大小。夹在中间的都是节。

下面介绍一些典型的节。

- `.text`：程序的机器代码
- `.rodata`：只读数据（read-only data）。比如说常量和常量字符串，switch 语句的跳转表都储存在这里。对只读数据段内存尝试修改将会导致段错误。
- `.data`：已初始化的全局和静态 C 变量。注意，局部变量不在 `.data` 或者 `.bss` 节中，而是储存在栈里。
- `.bss`：未初始化的或者被初始化为 0 的全局或者静态变量（反正就是 0）。在文件中，这个节不占据任何的磁盘空间，只有在运行时，才在内存中分配给这些变量空间，初始值为 0。这样做大大提高了空间效率，也是 `.bss` 节为什么总是全都为 0 的原因。
- `.symtab`：符号表，存放函数和全局变量的信息。
- `.debug`：调试符号表，只有以 `-g` 选项编译才能得到这张表，包络必要的调试信息。
- `.strtab`：一个字符串表，包括所有节的节名。

### Segment 视角

从段的视角，我们可以把 ELF 主要分为三段：代码段（`.text`，`.rodata`）、数据段（`.data`，`.bss`）和不加载到内存的符号表。其中，代码段只读，而数据段有读写权限。


Linux 程序调用 `execve` 函数来调用加载器，加载器将可执行目标文件的代码和数据复制到内存中，然后跳转到程序的入口点来运行程序。

下面我们来看一下程序运行时的内存映像。

![](https://cdn.jsdelivr.net/gh/peter5723/imagehost/links2.jpg){:height="50%" width="50%" }

在 Linux 系统中，程序的代码段总是从地址 `0x400000` 处开始，后面是数据段。堆在数据段之后，调用 `malloc` 库向上增长。用户栈从最大的合法用户地址开始（2**48-1），向下增长。用户栈之上的区域是内核的代码和数据，对用户不可见。


???+ note "练习"

    1. 为什么下面的语句会导致段错误？
    ```c
    char *p = "abcde";
    char *q = "edcba";
    strcpy(p, q);
    ```

    2. 使用 readelf 查看一个 ELF 文件的信息, 你会看到一个 segment 包含两个大小的属性, 分别是 FileSiz 和 MemSiz, 这是为什么? 再仔细观察一下, 你会发现 FileSiz 通常不会大于相应的 MemSiz, 这又是为什么?
    提示：MemSiz 是文件在磁盘中的大小，FileSiz 是文件运行时在内存中的大小。

## 2. 链接

这个[教程](https://blog.csdn.net/m0_37621078/article/details/88376228) 非常详细地介绍了如何在 linux 系统下使用静态库和动态库. 

一个静态库可以看成是一组目标文件(.o/.obj)的集合, 就是很多目标文件经过压缩打包后形成的文件. Linux 静态库命名规范，必须是`lib[your_library_name].a`：lib 为前缀，中间是静态库名，扩展名为 .a。静态库对函数库的链接在编译时期就完成了. 

动态库的出现, 为了解决静态库的问题. 代码虽然可以复用, 但是无法共享, 造成空间浪费. 静态库 a.lib 更新, 整个程序就要重新编译再发布给用户.

动态库程序编译时不会连接到代码中, 而是在运行时才被载入. 对用户来说, 只需要更新动态库即可.

Linux 动态库命名规范，必须是`lib[your_library_name].so`：lib为前缀，中间是静态库名，扩展名为 .so